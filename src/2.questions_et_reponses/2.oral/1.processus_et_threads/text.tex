\subsubsection{Processus et threads}

\paragraph{Question 1} (Processus et threads). Quel est le principal intérêt d'implémenter les threads dans l'espace utilisateur ? Et quel en est l'inconvénient majeur ?
\color{reponse}
\begin{itemize}
	\item L\'avantage est l'efficacité. La gestion en espace utilisateur est que le programmeur gère ses threads, et peut faire des choses sur mesure pour ses problèmes. Quand l'ordonnanceur est dans le noyau, on y a beaucoup moins accès. Le changement de threads est également bien plus léger.
	\item Un inconvénient de l'espace utilisateur est que l'OS ne voit pas les threads. Si un des threads est bloqué pour une raison ou une autre, c'est tout le processus qui va être bloqué.
\end{itemize}
\color{black}



\paragraph{Question 2} (Processus et threads).\begin{itemize}
	\item Définir le problème d'exclusion mutuelle ;
	\item La solution de Peterson au problème d'exclusion mutuelle (Figure \ref{Solution de Peterson}) fonctionne-t-elle lorsque l'ordonnancement est préemptif ? Non préemptif ?
\end{itemize}
\begin{figure}[p]
	\lstinputlisting[language=C]{2.questions_et_reponses/2.oral/1.processus_et_threads/code1.c}
	\caption{\label{Solution de Peterson} Solution de Peterson}
\end{figure}
\color{reponse}
\begin{itemize}
	\item Elle fonctionne avec l'ordonnancement préemptif. En fait, elle a été conçue pour cela. Lorsque l'ordonnancement n'est pas préemptif, il risque d'échouer. Prenons le cas où turn est initialement à 0 mais que le processus 1 s'exécute en premier. Il va boucler indéfiniment et ne libérera jamais le processeur.
\end{itemize}
\color{black}



\paragraph{Question 3} (Processus et threads). Décrire le problème des philosophes. La Figure \ref{Tentative de solution au probleme des philosophes} présente-elle une solution prétendue au problème des philosophes ? Quel est le souci avec cet algorithme, justifiez.
\begin{figure}[p]
	\lstinputlisting[language=C]{2.questions_et_reponses/2.oral/1.processus_et_threads/code2.c}
	\caption{\label{Tentative de solution au probleme des philosophes} Tentative de solution au problème des philosophes}
\end{figure}
\color{reponse}
\begin{itemize}
	\item En 1965, Dijkstra a posé et résolu un problème de synchronisation qu'il a appelé le problème du dîner des philosophes. Depuis lors, toutes les personnes ayant mis au point une nouvelle primitive de synchronisation se sont senties obligées de démontrer son grand intérêt en illustrant à quel point elle résolvait élégamment le problème.
\\Quel est-il ? Cinq philosophes sont assis autour d'une table ronde. Chacun a devant lui une assiete de spaghettis. Mais ceux-ci sont si glissant qu'il faut deux fourchettes pour les manger. Entre deux assiettes se trouve une fourchette.
\begin{center}
\includegraphics[scale=0.5]{2.questions_et_reponses/2.oral/1.processus_et_threads/dinerdesphilos.png}
\end{center}
Quand un philosophe a faim, il tente de s'emparer des fourchettes droite et gauche sans ordre défini. S'il y parvient, il mange pendant un moment, puis pose les fourchettes et se met à penser. La question est la suivante : pouvez-ouvs écrire un programme pour que chaque philosphe puisse exercer ces deux activités sans jamais se retrouver bloqué ?
\item Ici le code n'est pas une solution au problème. Car il faut gérer le problème avec une section critique.
\end{itemize}
\color{black}



\paragraph{Question 4} (Processus et threads). Expliquez le fonctionnement de l'appel système \textit{fork} de la norme \textsc{posix}. Qu'affiche à l'écran le pseudo-programme suivant :
\begin{lstlisting}
cout << "a" ; fork(); cout << "b"; fork(); cout << "c";
\end{lstlisting}
\color{reponse}
\begin{itemize}
	\item Ce code affiche "abbcccc". Le programme démarre, affiche "a" puis se sépare en deux processus qui vont chacun afficher "b" et se séparer eux aussi en 2 processus qui vont afficher "c", soit un total de 4 processus au final. La partie "bcc" peut être permutée en "cbc" ou "ccb" selon l'ordre de scheduling des processus.
\end{itemize}
\color{black}



\paragraph{Question 5} (Processus et threads). Considérez un ordinateur doté de deux processeurs, chacun disposant de deux threads (hyperthreading). Supposez que trois programmes, \textit{P0}, \textit{P1} et \textit{P2}, sont lancés avec des temps d'exécution de 5, 10 et 20 ms. Combien de temps mettra cet ordinateur pour exécuter globalement ces trois programmes ? Considérez que ces programmes sont 100\% en mémoire, qu'il n'y a pas de blocage pendant l'exécution et qu'il n'y a pas de changement de processeur une fois qu'il est assigné.
\color{reponse}
\begin{itemize}
	\item L'ordinateur peut mettre 20, 25 ou 30 ms pour exécuter globalement les programmes selon l'organistion de leur exécution par le système d'exploitation. 
		\begin{enumerate}
			\item Si \textit{P0} et \textit{P1} sont sur le même processeur et que \textit{P2} est lancé sur l'autre, il mettra 20 ms. 
			\item Si \textit{P0} et \textit{P2} sont sur le même processeur et que \textit{P1} est lancé sur l'autre, il mettra 25 ms.
			\item Si \textit{P1} et \textit{P2} sont sur le même processeur et que \textit{P0} est lancé sur l'autre, il mettra 30 ms.
			\item Si les trois sont lancés sur le même processeur, cela mettra 35 ms.
		\end{enumerate}
\end{itemize}
\color{black}



\paragraph{Question 6} (Processus et threads). Pour chacun des appels système fork, exec et unlink, donnez une condition d'échec.
\color{reponse}
\begin{itemize}
	\item fork peut échouer s'il n'y a pas de connecteur libre dans la table de processus et éventuellement, s'il ne reste plus de mémoire ou d'espace d'échange ;
	\item exec peut échouer si le nom du fichier donné n'existe pas ou s'il ne s'agit pas d'un fichier exécutable valide ;
	\item unlink peut échouer si le fichier à détruire n'existe pas ou si le processus appelant n'a pas l'autorité pour le faire.
\end{itemize}
\color{black}



\paragraph{Question 7} (Processus et threads). Pourquoi une table de processus est-elle nécessaire dans un système à temps partagé ? Est-elle également requise dans un système personnel où un seul processus existe, avec accès à toute la machine durant son exécution ?
\color{reponse}
\begin{itemize}
	\item La table de processus sert à stocker l'état d'un processus suspendu, qu'il soit prêt ou bloqué. Elle n'est pas nécessaire dans un système à processus unique, puisque celui-ci n'est jamais suspendu.
\end{itemize}
\color{black}



\paragraph{Question 8} (Processus et threads). Sur tous ordinateurs actuels, au moins une partie des gestionnaires d'interruption est écrite en langage d'assemblage. Pourquoi ?
\color{reponse}
\begin{itemize}
	\item Généralement, les langages évolués n'autorisent pas le type d'accès requis au matériel du processeur. Par exemple, il peut être nécessaire de disposer d'un handler d'interruption pour activer et désactiver l'interruption servant un périphérique particulier. En outre, les routines de service d'interruption doivent s'exécuter aussi rapidement que possible.
\end{itemize}
\color{black}



\paragraph{Question 9} (Processus et threads). Dans un système comprenant des threads, trouve-t-on une pile par thread ou une pile par processus lorsqu'il s'agit de threads utilisateur ? Que se passe-t-il lorsque l'on utilise des threads noyau ? Expliquez.
\color{reponse}
\begin{itemize}
	\item Chaque thread appelle ses propres procédures et doit donc disposer de sa propre pile pour les variables locales, les adresses de retour, etc. Cela est vrai pour les threads utilisateur et les threads noyau.
\end{itemize}
\color{black}



\paragraph{Question 10} (Processus et threads). Qu'est-ce qu'une section critique ? Quelles sont les règles à respecter ?
\color{reponse}
\begin{itemize}
	\item Les sections critiques sont la solution pour résoudre les problèmes de concurrence (Accès à une même donnée). Une section critique est une partie de code dans laquelle un seul processus à la fois peut rentrer. Elle n'est libérée que quand le traitement est complètement terminé.
\\Pour avoir une section critique, il faut respecter un certain nombre de règles, pour éviter les bugs :
		\begin{enumerate}
			\item On ne peut pas avoir plusieurs processus simultanément dans la région critique.
			\item On ne peut pas faire de suppositions sur les fréquences du processeur et sa vitesse.
			\item Aucun processus hors de sa section critique ne peut bloquer un autre processus. Quand on n'est pas intéressé, on laisse tranquille.
			\item Tout cela doit être équitable. Tout processus qui un jour ou l'autre veut entrer dans la section critique doit un jour rentrer dedans.
		\end{enumerate}
Quand un processeur entre dans la section critique, il peut d'abord avoir à attendre. Quand un processus sort de la section critique, un autre processus attendant la section critique est réveillé. Ce sont les opérations "lock" et "unlock".
\end{itemize}
\color{black}



\paragraph{Question 11} (Processus et threads). À la Figure \ref{perProcessItemPerThreadItems}, le jeu de registres est classé par éléments de thread, et non par éléments de processus. Pourquoi ? Après tout, l'ordinateur ne possède qu'un seul jeu de registres.
\begin{figure}[p]
	\centering
	\includegraphics[scale=0.1]{2.questions_et_reponses/2.oral/1.processus_et_threads/perProcessItemPerThreadItems.png}
	\caption{\label{perProcessItemPerThreadItems} Processus et thread}
\end{figure}
\color{reponse}
\begin{itemize}
	\item 
\end{itemize}
\color{black}